# Web(Spring)

<br/>

<br/>

<br/>

#### Spring Framework의 주요 특징에 대해 소개해주세요.

> Spring Framework의 특징은
>
> 1. 첫번째, 경량 컨테이너로서 자바 객체를 직접 관리합니다.
>    각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있습니다.
> 2. 두번째, 제어의 역행(IoC)입니다.
>    컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어 필요에 따라 스프링에서 사용자의 코드를 호출합니다.
> 3. 세번째, 의존성 주입(DI)입니다.
>    각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜줍니다.
> 4. 네번째, 관점지향 프로그래밍(AOP)입니다.
>    트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있습니다.

<br/>

<br/>

<br/>

#### Spring, Spring Boot, Spring MVC 차이는 무엇인가요

> 

<br/>

<br/>

<br/>

#### IoC에 대해 설명해주세요

> 

<br/>

<br/>

<br/>

#### DI에 대해 설명해주세요

> DI는 객체 자체가 아니라 프레임워크에 의해 객체의 의존성이 주입되는 것입니다. 각 클래스 사이에 필요로 하는 의존관계를 Bean 설정 정보 바탕으로 스프링 컨테이너가 자동으로 연결합니다.
>
> DI의 장점은
>
> 1. 결합도가 낮아지게 되어서 유지보수와 확장에 유리합니다.
> 2. 의존 객체를 Mock으로 대체할 수 있으므로 테스트가 용이해집니다.
> 3. 종속성이 감소합니다. 구성 요소의 종속성이 감소하면, 변경에 민감하지 않습니다.

<br/>

<br/>

<br/>

#### Dispatcher Servlet에 대해 설명해주세요.

> Dispatcher Servlet는 클라이언트의 모든 요청을 받아서 필요한 처리를 하고, 요청에 맞는 Handler로 요청을 Dispatch하고, 해당 Handler의 실행결과를 HTTP Response로 만드는 역할을 합니다.

<br/>

<br/>

<br/>

#### AOP에 대해 설명해주세요

> AOP는 어플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 모듈로 만들어서 설계하고 개발하는 방법입니다. 즉, 공통 부분을 모듈로 분리하는 것이며 주로 인증, 로깅, 트랜잭션 처리에 사용됩니다.

<br/>

<br/>

<br/>

#### AOP의 용어들에 대해 설명해주세요(Target, Aspect, Advice, PointCut, JoinPoint 등)

> Aspect: 애스펙트는 AOP의 기본 모듈이며, 애스펙트는 부가기능을 정의한 코드인 어드바이스(Advice)와 어드바이스를 어디에 적용하지를 결정하는 포인트컷(PointCut)을 합친 개념입니다.
>
> Target: 부가기능을 부여할 대상입니다.
>
> Advice: 어드바이스는 타겟에 제공할 부가기능을 담고 있는 모듈입니다.
>
> JoinPoint: 어드바이스가 적용될 수 있는 위치를 얘기합니다. 다른 AOP 프레임워크와 달리 Spring에서는 메소드 조인포인트만 제공하고 있습니다.
>
> PointCut: 부가기능이 적용될 대상(메소드)를 선정하는 방법을 의미합니다.
>
> Weaving: 위빙은 포인트컷에 의해서 결정된 타겟의 조인 포인트에 부가기능(어드바이스)를 삽입하는 과정을 뜻합니다.

<br/>

<br/>

<br/>

#### Spring AOP의 특징에 대해 설명해주세요.

> 첫번째 특징은 Spring이 프록시 기반 AOP를 지원하는 것입니다.
> Spring은 타겟 객체에 대한 프록시를 만들어 제공하고, 그 프록시는 런타임에 생성됩니다.
>
> 두번째 특징은 프록시가 호출을 가로채는 것입니다. 프록시는 타겟 객체에 대한 호출을 가로챈 다음 어드바이스의 부가기능 로직을 수행하고 난 후에 타겟의 핵심기능 로직을 호출합니다. 혹은 호출을 가로챈 후 핵심기능 로직을 호출한 후에 부가기능을 수행합니다.
>
> 세번째 특징은 Spring이 동적 프록시를 기반으로 AOP를 구현하므로 메서드 조인 포인트만 지원하는 것입니다. 핵심기능(타겟)의 메서드가 호출되는 런타임 시점에만 부가기능(어드바이스)을 적용할 수 있습니다.
>
> 반면에 AspectJ 같은 고급 AOP 프레임워크를 사용하면 객체의 생성, 필드값의 조회와 조작, static 메서드 호출 및 초기화 등의 다양한 작업에 부가기능을 적용 할 수 있습니다.

<br/>

<br/>

<br/>

#### Filter와 Interceptor에 대해 소개해주세요

>  Filter는 dispatcher servlet에 요청이 전달되기 전후에 동작하며, url 패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공합니다. Spring Context 내부가 아닌, 톰캣과 같은 웹 컨테이너에 의해 관리됩니다.
>  Filter에는 init, doFilter, destroy 메서드가 있습니다. 
>  init 메서드는 필터 객체를 초기화하고, 서비스에 추가하기 위한 메서드입니다. 웹 컨테이너가 1회 init 메소드를 호출하여 필 터 객체를 초기화하면 이후의 요청들은 doFilter를 통해 전/후에 처리된다.
>  doFilter 메서드는 url 패턴에 맞는 모든 HTTP 요청이 디스패처 서블릿으로 전달되기 전/후에 웹 컨테이너에 의해 실행되는 메소드입니다.
>  destroy 메소드는 필터 객체를 서비스에서 제거하고 사용하는 자원을 반환하기 위한 메소드입니다.
>
>  Interceptor는 스프링이 제공하는 기능으로, Dispatcher Servlet이 컨트롤러를 호출하기 전/후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공합니다. 

![Spring Flow 이미지](./image/spring_flow.png)

<br/>

<br/>

<br/>



#### Transaction의 처리 과정에 대해 설명해주세요

<br/>

<br/>

<br/>

#### `Controller`과 `RestController`의 차이에 대해 설명해주세요

> Controller는 보통 View를 반환하는 목적으로 쓰이며, Data를 반환해야 하는 경우에는 @ResponseBody 어노테이션을 사용해야 합니다.
>
> RestController는 Controller에 @ResponseBody가 합쳐진 것으로 Json/Xml 형태로 객체 데이터를 반환하는 것이 주용도입니다. 

<br/>

<br/>

<br/>

#### Bean Scope 종류와 특징을 말해주세요.

> - singleton: 하나의 Bean 정의에 대해서 Spring IoC 컨테이너 내에 단 하나의 객체만 존재하는 것입니다. bean scope이 지정되지 않으면 기본적으로 싱글톤입니다.
>
> - prototype: 프로토타입은 모든 요청에 대해 새로운 객체를 생성합니다.
> - request: 하나의 Bean 정의에 대해 하나의 HTTP Request의 생명주기 안에 단 하나의 객체만 존재합니다.
> - session: 하나의 Bean 정의에 대해 하나의 HTTP Session의 생명주기 안에 단 하나의 객체만 존재합니다.

<br/>

<br/>

<br/>

#### @Transactional 의 propagation(전파옵션)에 대해 설명해주세요.

> - REQUIRED
>   - 부모 트랜잭션이 없으면 트랜잭션을 생성하고, 부모 트랜잭션이 있다면 부모 트랜잭션 내에서 실행한다.
>   - default 값이다.
>   - 만약 자식 트랜잭션이 실패시 부모 트랜잭션까지 같이 롤백된다. (부모,자식 모두 한 트랜잭션이니까 당연하다)
>   - 의리
> - REQUIRES_NEW
>   - 항상 새로운 트랜잭션을 생성한다.
>   - 부모 트랜잭션에 문제가 생겨서 부모 트랜잭션이 롤백되더라도 자식 트랜잭션은 롤백이 일어나지 않으며, 반대도 마찬가지다.
>   - 각개전투
> - SUPPORTS
>   - 부모 트랜잭션이 있으면 부모 트랜잭션 내에서 실행되며, 부모 트랜잭션이 없으면 트랜잭션 없이 실행한다.
> - NESTED
>   - 부모 트랜잭션이 없다면 새로운 트랜잭션을 생성하고, 부모 트랜잭션이 있으면 중첩 트랜잭션을 생성한다.
>   - 부모 트랜잭션에서 롤백이 되면 중첩 트랜잭션도 롤백된다. 중첩 트랜잭션이 롤백되어도 부모 트랜잭션에는 영향을 미치지 않는다.
> - MANDATORY
>   - 부모 트랜잭션이 있으면 부모 트랜잭션에 합류하고, 부모 트랜잭션이 없을 경우 예외를 발생시킨다.
>   - 독립적으로 트랜잭션을 실행하면 안되는 경우에 사용한다.
> - NOT_SUPPORTED
>   - 트랜잭션을 사용하지 않게 하고, 이미 진행 중인 트랜잭션이 있으면 보류시킨다.
> - NEVER
>   - 트랜잭션을 생성하지 않는다. 부모 트랜잭션이 존재한다면 예외를 발생시킨다.

<br/>
<br/>
<br/>

#### @Transactional 의 isolation level(격리 수준)에 대해 설명해주세요.

> - READ UNCOMMITTED
>   - 트랜잭션의 커밋이나 롤백 여부에 상관없이 다른 트랜잭션에서 데이터를 읽을 수 있습니다. 
>   - 한 트랜잭션의 수정이 커밋되지 않았는데, 다른 트랜잭션에서 수정된 데이터를 읽을 수 있어서 정합성 문제가 발생할 수 있습니다. (Dirty Read 발생) 
> - READ COMMITTED
>   - Commit된 데이터만 읽어 올 수 있습니다.
>   - 하지만 하나의 트랜잭션내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 하는 `REPEATABLE READ`의 정합성에 어긋납니다.
> - REPEATABLE READ
>   - 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준입니다.
>   - NON-REPEATABLE 부정합은 발생하지 않으나 PHANTOM READ가 발생할 수 있습니다.
>   - PHANTOM READ는 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안보였다가 하는 현상입니다.
> - SERIALIZABLE
>   - 가장 엄격한 격리 수준이며, Phantom Read는 발생하지 않지만 동시성 처리 성능이 가장 낮습니다.
> - 이 부분은 Real My SQL 191 페이지를 참고하자.

<br/>
<br/>
<br/>

#### @Transactional 의 readOnly 속성에 대해 설명해주세요.

> 

<br/>
<br/><br/>
<br/>
<br/>

# JPA

<br/>

<br/>

<br/>

<br/>

#### JPA의 장점?

> - 장점
>   - [생산성] 자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면 되므로 생산성이 증가합니다. 
>   - [유지보수] SQL을 직접 다루면 등록, 수정, 조회 SQL과 결과를 매핑하기 위한 JDBC API 코드를 모두 변경해야 합니다. 반면에 JPA를 사용하면 이런 과정을 JPA가 대신 처리해주므로 필드를 추가하거나 삭제해도 수정해야 할 코드가 줄어듭니다.
>   - [성능] JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기능을 제공합니다. 성능 최적화 기능에는 1차 캐시, 쓰기 지연, 지연 로딩이 있습니다. 
> - 단점
>   - 높은 러닝커브와 메서드 호출로 DB 데이터를 조작하기 때문에 세밀함이 떨어집니다. 세밀함을 보안하기 위해 JPQL을 지원하는 것으로 알고 있습니다.

<br/>

<br/>

<br/>

<br/>

#### 영속성 컨텍스트가 무엇인가?

>  영속성 컨텍스트란 "엔티티를 영구 저장하는 환경"이라는 뜻입니다. 즉, 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리합니다. 영속성 컨텍스트 내에는 1차 캐시, 쓰지 지연 저장소가 있습니다.

<br/>

<br/>

<br/>

<br/>

<br/>

#### 영속성 컨텍스트가 엔티티를 관리하는 것의 장점은? 

> 영속성 컨텍스트가 엔티티를 관리하는 것의 장점은 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기지연, 변경 감지(dirty checking), 지연 로딩이 있습니다.
>
> 영속성 컨텍스트 내에 1차 캐시가 있어서 성능상 이점이 있고, 덕분에 동일성을 보장합니다.
>
> 트랜잭션을 지원하는 쓰기지연은 DB 커넥션 시간을 줄일 수 있습니다.
>
> 변경 감지 덕분에 update메서드를 사용하지 않아도 영속 상태인 엔티티의 값을 변경시킬 수 있습니다.

<br/>

<br/>

<br/>

#### JPA의 성능 최적화 기능은 어떤 것들이 있나요?

> JPA의 성능 최적화 기능은 1차 캐시, 쓰기 지연, 지연 로딩이 있습니다.
> 1차 캐시는 영속성 컨텍스트 내부에 있는 캐시로, 한 트랜잭션 내에서 사용되기 때문에 데이터베이스에 접근하는 빈도가 줄어듭니다. 예를 들어, 같은 회원을 두 번 조회해야할 때, JPA를 사용하면 처음에만 SELECT SQL로 찾아오고 두 번째는 1차 캐시에 있는 회원을 가져와서 중복된 쿼리의 동작을 줄여줍니다. 쓰기 지연은 쿼리들을 영속성 컨텍스트 내의 쓰기 지연 저장소에 저장하고 있다가 트랜잭션이 커밋하는 순간 DB에 쿼리를 날립니다. 지연 로딩은 연관된 객체를 실제로 사용할 때 가져오는 것입니다.

<br/>

<br/>

<br/>

<br/>

<br/>

#### Fetch Type에 대해 설명해주세요

<br/>

<br/>

 <br/>

<br/>

## REFERENCE

> - [AOP](https://shlee0882.tistory.com/206)
>
> - [AOP-이동욱님](https://jojoldu.tistory.com/71)
> - [Controller VS RestController, Filter&Interceptor - 망나니 개발자](https://mangkyu.tistory.com/49)
