# Java

<br/>

<br/>

#### JVM에 대해 설명해주세요.

> JVM은 자바 가상 머신으로 자바 바이트 코드를 실행할 수 있는 주체입니다. 
>
> 운영체제 위에서 동작하는 프로세스로 자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할을 합니다. JVM은 Class Loader, Execution Engine, GC, Runtime Data Area로 구성되어 있습니다.
>
> JVM의 장점은 JVM 위에서 바이트코드는 CPU나 운영체제의 종류와 무관하게 실행이 가능하다는 것과 GC가 메모리를 자동으로 관리해준다는 것입니다.

<br/>

<br/>

<br/>

#### JVM 구성 각각에 대해 설명해주세요.

> Class Loader는 JVM내로 클래스(.class파일)를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈입니다. 런타임 시에 동적으로 클래스를 로드합니다.
>
> Execution Engine은 메모리에 적재된 클래스(바이트 코드)들을 기계어로 변경해 명령어 단위로 실행하는 역할을 합니다. 그 과정은 인터프리터 방식, JIT 컴파일러를 이용하는 방식이 있습니다.
>
> Garbage Collector(GC)는 Heap 메모리 영역에 생성(적재)된 객체들 중에 참조되지 않는 객체들을 탐색 후 제거하는 역할을 합니다. GC가 수행되는 동안 GC를 수행하는 쓰레드가 아닌 다른 모든 쓰레드가 일시정지되는 특징이 있습니다.
>
> Runtime Data Area는 JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역입니다. 이 영역은 크게 Method 영역, Heap 영역, Stack 영역, PC Register, Native Method Stack으로 구성되어 있습니다.

<br/>

<br/>

<br/>

#### JVM 메모리 공간에 대해 설명해주세요.

> JVM 메모리는 크게 Method 영역, Heap 영역, 스택 영역, PC 레지스터, Native Method Stack으로 구성되어 있습니다.
>
> Method 영역은 클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 공간입니다. 저장되는 대상은 필드 정보(멤버 변수의 이름, 데이터 타입, 접근 제어자 정보), 메서드 정보(메서드 이름, 리턴 타입, 접근 제어자 정보), 타입 정보(class인지 interface인지), 상수 풀 등이 있습니다.
>
> Heap 영역은 런타임에 동적으로 할당되는 데이터가 저장되는 영역입니다. 객체나 배열이 이곳에 저장됩니다. 그리고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역입니다.
>
> Stack 영역은 지역변수, 매개변수, 메서드 정보, 임시 데이터 등을 저장하는 영역입니다. 
>
> PC 레지스터는 Thread(쓰레드)가 생성될 때마다 생성되는 영역으로 Program Counter 즉, 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역입니다. (CPU의 레지스터와 다름)
>
> Native Method Stack은 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역입니다.

<br/>

<br/>

<br/>

#### 자바 프로그램 실행 과정을 설명해주세요.

> 1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받습니다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리합니다.
> 2. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환시킵니다.
> 3. Class Loader를 통해 .class 파일들을 JVM으로 로딩합니다.
> 4. 로딩된 .class 파일들은 Execution engine을 통해 해석됩니다.
> 5. 해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게 됩니다.
>
> 이러한 실행과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC 같은 관리작업을 수행합니다.

<br/>

<br/>

<br/>

#### GC가 무엇인가요? (GC 정의, 종류 등)

> 

<br/>

<br/>

<br/>

#### 인터페이스와 추상클래스에 대해 설명해주세요(용도, 차이 등)

> 인터페이스는 구현하는 클래스에 특정한 메서드가 반드시 존재하도록 강제하는 역할입니다. java 8부터는 default 키워드를 통해 꼭 정의하지 않아도 됨을 명시주는 기능이 추가되었습니다.
>
> 추상 클래스는 실체 클래스에서 공통적인 부분을 추출해 선언한 클래스이고, 반드시 재정의 해야하는 추상메서드를 통해 규격을 제공합니다.
>
> 인터페이스와 추상클래스로는 인스턴스를 생성할 수 없으며, 인터페이스는 다중 상속이 가능하지만 추상 클래스는 다중 상속이 불가능합니다.

<br/>

<br/>

<br/>

#### static 에 대해 설명해주세요.

>Static 키워드를 사용한다는 것은 메모리에 한번 할당되어 프로그램이 종료될 때 해제되는 것을 의미합니다. Static 키워드를 사용한 변수나 메서드는 JVM 메모리의 Method 영역에 저장됩니다.
>
>Static 키워드를 통해 Method 영역에 할당된 메모리는 모든 객체가 공유하는 메모리라는 장점을 가지고 있습니다.
>
>Garbage Collector의 관리 영역 밖에 존재하기 때문에 Static을 사용하면 프로그램 종료시까지 메모리가 할당된 채로 존재하게 됩니다. 따라서 무분별하게 사용한다면 오히려 메모리 낭비가 될 수 있다는 단점이 있습니다.

<br/>

<br/>

<br/>

#### final 에 대해 설명해주세요.

> 자바에서 final은 단 한 번만 할당할 수 있도록 제한해주는 키워드입니다. 그리고 클래스, 메서드, 변수에 선언함에 따라 각각 특징을 가지고 있습니다.
>
> 클래스에 선언한 경우, 해당 클래스를 다른 클래스가 상속 받을 수 없습니다.
>
> 메서드에 선언한 경우, 해당 메서드를 오버 라이드 할 수 없습니다.
>
> 변수에 선언한 경우, 원시 변수라면 해당 변수의 값을 변경할 수 없고 참조 변수라면 해당 참조 변수가 힙(Heap)의 다른 객체를 가리키도록 할 수 없습니다.  

<br/>

<br/>

<br/>

#### 클래스와 인스턴스가 무엇인지 설명해주세요.

> 클래스는 어떤 문제를 해결하기 위한 데이터를 만들기기 위해 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것입니다. 즉, 객체를 만들기 위한 틀입니다.
> 인스턴스는 클래스에서 정의한 것을 토대로 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터입니다. 

<br/>

<br/>

<br/>

#### 제네릭에 대해 설명해주세요.

> 제네릭(Generic)은 클래스 내부에서 사용하는 데이터의 타입(Type)을 클래스의 인스턴스를 생성할 때 결정하는 것을 의미합니다. 객체 생성이 가능한 타입에 대해서만 제네릭(Generic) 사용이 가능하며, 생성자 인자로 넣어줄 경우에는 생성시 제네릭을 생략할 수 있습니다.
>
> 제네릭의 장점은 객체의 타입을 컴파일 시점에 체크하기 때문에 타입 안정성을 높이고 형 변환의 번거로움을 줄일 수 있습니다.

<br/>

<br/>

<br/>

#### `class A<T extends B>` 에 대해 설명해주세요.

> T 매개변수의 타입은 B 객체 타입이거나 B 클래스를 상속받는 클래스의 타입만 올 수 있도록 제한하겠다는 의미입니다. 

<br/>

<br/>

<br/>

#### 오버라이딩과 오버로딩에 대해 설명해주세요.

> 오버로딩은 한 클래스 내에 이름이 같은 메서드를 여러개 정의하는 것입니다. 파라미터의 자료형이나 갯수가 다르지만 동일한 역할을 하는 메서드를 여러 개 만들 수 있습니다.
>
> 오버라이딩은 상위 클래스의 메서드를 재정의하는 것을 의미합니다. 메서드의 반환type, 파라미터 등은 모두 같으며 내부만 재정의하는 것입니다.

<br/>

<br/>

<br/>

#### 동등성과 동일성의 차이는?

> 동일성은 두 객체가 같은 객체인 것을 말하고, 동등성은 두 객체가 동일한 정보를 담고 있는 것을 의미합니다.
>
> 동일성은 == 연산자, 동등성은 equals 메서드를 사용합니다.
>
> 최상위 클래스인 Object의 equals 메서드는 동일성을 확인하도록 되어 있어서 equals 메서드를 오버라이딩해서 동등성을 확인하도록 해야합니다.

<br/>

<br/>

<br/>

#### Java Collection 각각에 대해 설명해주세요.

> Java Collection의 핵심 인터페이스는 List, Set, Map이 있습니다.
> <br/>
>
> List는 순서가 있는 집합이며, 데이터 중복을 허용합니다. 구현 클래스로는 ArrayList, LinkedList, Vector가 있습니다.
>
> Set은 데이터의 순서를 유지하지 않고, 중복을 허용하지 않습니다. 구현클래스로는 HashSet, TreeSet이 있습니다.
>
>  Map은 Key와 Value의 쌍으로 이루어진 데이터의 집합입니다. 순서는 유지되지 않고, Key의 중복은 허용하지 않으며 Value의 중복은 허용합니다. 구현클래스로는 HashTable, HashMap, TreeMap이 있습니다.

<br/>

<br/>

<br/>

#### Java 8에 변경된 부분에 대해 설명해주세요.

> 

<br/>

<br/>

<br/>

#### Stream API에 대해 설명해주세요.

> 

<br/>

<br/>

<br/>

#### 람다식에 대해 설명해주세요.

> 

<br/>

<br/>

<br/>

#### Call By Value와 Call By Reference에 대해 설명해주세요.

> 

<br/>

<br/>

<br/>

#### Java는 Call By Value일까요? Call By Reference일까요?

> 

<br/>

<br/>

<br/>

#### String VS StringBuilder VS StringBuffer ?

> 한번 생성된 String 인스턴스가 갖고 있는 문자열은 읽어 올 수만 있고, 변경할 수는 없습니다. `+` 연산자를 이용해서 문자열을 결합하는 경우, 인스턴스 내의 문자열이 바뀌는 것이 아니라 새로운 문자열이 담긴 String 인스턴스가 생성되어 메모리 공간을 차지하게 됩니다. 따라서 GC(Garbage Collector)가 호출되기 전까지 연산할 때 쓰인 String들이 heap에 계속 쌓이므로 메모리 관리 측면에서 치명적입니다.
>
> String 클래스는 인스턴스를 생성할 때 지정된 문자열을 변경할 수 없지만 StringBuffer 클래스는 변경이 가능합니다. 내부적으로 문자열 편집을 위한 버퍼(buffer)를 가지고 있으며, StringBuffer 인스턴스를 생성할 때 그 크기를 지정할 수 있다.
>
> StringBuffer는 멀티쓰레드에 안전(thread safe)하도록 동기화되어 있습니다. 따라서 멀티쓰레드로 작성된 프로그램이 아닌 경우, StringBuffer의 동기화는 불필요하게 성능만 떨어뜨리게 됩니다.
>
> 그래서 StringBuffer에서 쓰레드의 동기화만 뺀 StringBuilder가 추가된 것입니다. StringBuilder는 StringBuffer와 완전히 똑같은 기능으로 작성되어 있습니다.

<br/>

<br/>

<br/>



#### Reference

> - [JVM-Jbee님](https://asfirstalways.tistory.com/158)
> - [JVM-정아마추어님](https://jeong-pro.tistory.com/148)
> - [제네릭](https://lktprogrammer.tistory.com/177)







#### 