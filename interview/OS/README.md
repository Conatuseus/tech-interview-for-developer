# OS

<br/>

<br/>

<br/>

#### 메모리 계층 구조에 대해 설명해주세요

> 메모리 계층 구조에는 레지스터, 캐시, 메인 메모리, 하드 디스크가 있습니다.
>
> 레지스터와 캐시는 CPU 내부에 존재해서 아주 빠르게 접근할 수 있습니다. 메모리는 CPU 외부에 존재하므로 레지스터와 캐시에 비해 접근 속도가 느립니다. CPU가 하드 디스크에 접근하기 위해서는 하드 디스크의 데이터를 메모리로 이동시키고, 메모리에서 접근해야하므로 가장 느립니다.

<br/>

<br/>

<br/>

#### 캐시란 무엇인가요

> 캐시 메모리란 CPU의 처리속도와 주기억장치의 접근 속도 차이를 줄이기 위해 사용하는 범용 메모리입니다. 캐시는 빠르다는 장점이 있지만 가격이 비싼 단점이 있습니다. 캐시의 성능은 작은 용량의 캐시 메모리에 CPU 가 이후에 참조할, 쓸모 있는 정보가 어느 정도 들어있느냐에 따라 좌우됩니다.
>
> 따라서 캐시는 적중률(Cache Hit Rate)을 높히기 위해 지역성(Locality)의 원리를 사용합니다. 지역성의 원리는 시간 지역성과 공간 지역성이 있습니다. 시간 지역성은 최근에 참조된 주소의 내용은 곧 다시 참조되는 특성이며, 공간 지역성은 현재 참조된 주소와 인접한 주소의 내용이 앞으로 참조될 가능성이 높은 특성입니다. 

<br/>

<br/>

<br/>

#### 프로세스와 쓰레드 차이에 대해 설명해주세요

> 프로세스는 실행 중인 프로그램으로 운영체제로부터 시스템 자원을 할당받는 작업의 단위입니다. 스레드는 이 프로세스 내에서 실행되는 흐름 단위입니다. 
>
> 프로세스마다 최소 하나의 스레드를 가지고 있으며, 각각 별도의 주소공간을 할당 받습니다. 프로세스 내에는 code, data, heap, stack 영역이 있습니다. 스레드는 이 영역 중 stack만 따로 할당받고 나머지 영역은 스레드끼리 공유합니다.

<br/>

<br/>

<br/>

#### Context Switching이란 무엇인가요?

> Context Switching은 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정을 말합니다. 
>
> Context Switching의 과정은 다음과 같습니다.
>
> - Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리되고 있습니다.
> - 현재 실행하고 있는 Task의 PCB 정보를 저장하게 됩니다. (Process Stack, Ready Queue)
> - 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행을 할 수 있습니다.

<br/>

<br/>

<br/>

#### PCB는 무엇인가요?

> PCB(Process Control Block)는 운영체제가 프로세스에 대한 정보를 저장해놓는 곳입니다. 프로세스 식별자, 프로세스 상태, Program Counter(다음에 실행할 명령어의 주소값), 포인터 등이 저장되어 있습니다. 각 프로세스가 생성될 때마다 고유의 PCB가 생성되며 프로세스가 완료되면 PCB는 제거됩니다.

<br/>

<br/>

<br/>

#### 멀티 프로그래밍?

> 멀티 프로그래밍은 프로세서의 자원 낭비를 최소화하기 위해 낭비하는 시간을 다른 프로세스 수행에 쓰게 하여, 하나의 프로세서에서 여러 프로세스를 교대로 수행할 수 있게 하는 것입니다.

<br/>

<br/>

<br/>

#### 멀티 프로세싱 vs 멀티 쓰레딩?

> 멀티 프로세싱은 컴퓨터 시스템 한 대에 둘 이상의 중앙 처리 장치(CPU)를 이용하여 병렬로 처리하는 것을 가리킵니다. 멀티 스레드(multi thread)란 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것을 의미합니다.
>
> 멀티 쓰레딩을 사용하면 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능합니다. 그리고 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소합니다.
>
> 하지만 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 '동기화'에 신경써야 합니다.

<br/>

<br/>

<br/>

#### CPU 스케줄링에 대해 설명해주세요

> CPU 스케줄링은 멀티 프로그래밍을 가능하게 하는 운영체제의 동작 기법입니다. "어떻게 프로세스들이 CPU를 효율적으로 사용하게 할 것인가?" 라는 고민에서 CPU 스케줄링이 출발한다고 할 수 있습니다.
>
> CPU 스케줄링은 선점형 스케줄링과 비선점형 스케줄링이 있습니다.
>
> 선점형 스케줄링은 CPU가 어떤 프로세스에 의해 점유 중일 때, 우선 순위가 높은 프로세스가 CPU를 차지할 수 있습니다. 따라서 우선순위가 높은 프로세스를 빠르게 처리해야할 경우에 유용합니다. 하지만 선점이 일어날 경우, 컨텍스트 스위칭으로 인한 오버헤드가 발생하며 처리시간을 예측하기 힘들다는 단점이 있습니다.
>
> 비선점형 스케줄링은 프로세스가 CPU를 점유하고 있다면 빼앗을 수 없는 방식입니다. 필요한 문맥 교환만 일어나기 때문에 오버헤드가 상대적으로 적지만 프로세스의 배치에 따라 효율성 차이가 많이 납니다.

<br/>

<br/>

<br/>

#### CPU 스케줄링 알고리즘에 대해 설명해주세요.

> 선점형 스케줄링에는 SRT, 라운드 로빈(Round Robin), 다단계 큐(Multi-level Queue), 다단계 피드백 큐 스케줄링이 있습니다.
>
> SRT(Shortest Remaining Time) 스케줄링은 남은 처리 시간이 짧은 프로세스가 먼저 수행되는 방식입니다. 현재 실행하고 있는 프로세스보다 남은 시간이 더 짧은 프로세스가 Ready 큐에 들어오면 해당 프로세스가 CPU를 빼앗아 수행하게 됩니다. 평균 대기 시간이 가장 짧은 알고리즘이지만, 잦은 문맥 교환으로 인한 오버헤드와 starvation 발생이 단점입니다.
>
> 라운드 로빈(Round Robin)은 각 프로세스에게 동일한 CPU 할당 시간을 부여해서 이 시간동안만 CPU를 이용하는 방식입니다. 모든 프로세스가 최초 응답 시간을 빠르게 보장받을 수 있다는 것이 장점입니다. 할당 시간이 너무 크면 FCFS(선입선출)과 다를 바가 없어지며, 너무 작으면 문맥 교환으로 인한 오버헤드가 커집니다.
>
> 다단계 큐는 Ready큐를 여러 개 사용하는 기법입니다. 각각의 큐는 자신의 스케줄링 알고리즘을 수행하며, 큐와 큐 사이에도 우선순위를 부여합니다.
>
> 다단계 피드백 큐는 다단계 큐의 공평성 문제를 완화하기 위해 신분 하락이 가능한 방식입니다. 이 알고리즘에서는 우선순위가 변동되기 때문에 큐 사이의 이동이 가능합니다.
>
> 비선점형 스케줄링에는 FCFS(선입선출), HRN, SJF, 우선순위 스케줄링이 있습니다.
>
> FCFS(First Come First Served)는 선입선출 방식으로, Ready 큐에 도착한 순서대로 CPU를 할당합니다. 프로세스의 CPU 처리 시간을 따로 고려하지 않기 때문에 매우 단순하고 공평한 방법입니다. 하지만 CPU 처리 시간이 긴 프로세스가 앞에 올 경우 뒤의 프로세스가 오래 기다려야 하기 때문에 비효율적이게 됩니다.
>
> HRN(Highest Response Ratio Next)는 수행시간의 길이와 대기 시간을 모두 고려해 우선순위를 정하는 방식입니다. 긴 작업과 짧은 작업간의 지나친 불평등을 어느 정도 보완한 기법입니다. "우선순위 = (대기시간+서비스시간)/서비스시간"
>
> SJF(Shortest Job First)는 큐 안에 있는 프로세스 중 수행시간이 짧은 것을 먼저 수행하는 방식입니다. 평균 대기 시간을 감소시키지만, starvation 현상이 발생할 수 있습니다.
>
> 우선순위는 프로세스에게 우선순위를 정적, 혹은 동적으로 부여하여 우선순위가 높은 순서대로 처리합니다. 동적으로 부여할 경우, 구현이 복잡하고 오버헤드가 많다는 단점이 있으나, 시스템의 응답속도를 증가시킵니다.

<br/>

<br/>

<br/>

#### 교착상태(Deadlock)에 대해 설명해주세요. (정의, 일어나는 조건 등)

> 교착상태는 프로세스가 필요한 자원을 획득하지 못해 영구적으로 블록되어 있는 상태를 말합니다. 예를 들어, 프로세스 A는 자원 1을 사용하고 있는 상태에서 자원 2를 필요로하며, 프로세스 B는 자원 2를 사용하고 있는 상태에서 자원 1을 필요로 합니다. 프로세스 A가 자원 1의 사용을 끝내려면 자원 2가 필요한데 프로세스 B가 이미 자원2를 사용하고 있기 때문에 대기해야 합니다. 즉, 서로의 자원을 사용하고 싶은데 서로가 쓰지 못해 무한대기하는 상황이 생기는데 이것을 교착상태라 합니다.
>
> 교착상태가 발생하는 조건은 4가지가 있습니다.
>
> - 상호배제: 한 순간에 한 프로세스만이 자원을 사용할 수 있습니다.
> - 점유대기: 이미 자원을 보유한 프로세스가 다른 자원을 요청하며 기다리고 있습니다.
> - 비선점: 프로세스에 의해 점유된 자원을 다른 프로세스가 강제적으로 빼앗을 수 없습니다.
> - 환형대기: 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있습니다.

<br/>

<br/>

<br/>

#### 교착상태 해결 방법에 대해 소개해주세요.

> - 예방: 교착상태 예방 전략은 운영체제를 설계할 때 교착상태가 발생할 가능성을 없애는 방법입니다. 따라서 교착상태가 발생하기 위한 네 가지 필요충분조건 중에 하나를 설계 단계에서 배제하는 것입니다. 예방은 자원 사용과 프로세스 수행에 비효율성을 야기할 수 있습니다.
> - 회피: 회피는 자원을 할당하기 전에 교착상태에 빠질 가능성이 있는지 확인하고, 빠질 가능성이 없을때만 자원을 할당하는 방법입니다. 회피 방법의 대표적인 알고리즘은 은행원 알고리즘이 있습니다.
> - 회복: 회복은 프로세스가 필요한 자원이 할당 가능하면 항상 할당해주며, 주기적으로 교착상태가 발생했는지 검사하고 회복하는 방법입니다.
> - 무시: 회복과정의 성능저하가 더 심하다면 무시하는 방법입니다.

<br/>

<br/>

<br/>

#### 세마포어와 뮤텍스에 대해 설명해주시고, 각각의 차이를 말씀해주세요.

> 세마포어와 뮤텍스 모두 여러 프로세스나 쓰레드가 공유 자원에 접근하는 것을 제어하기 위한 방법입니다.
>
> 첫번째 차이점은 세마포어는 공유자원에 세마포어 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있으며, 뮤텍스는 오직 1개만의 프로세스만이 접근할 수 있습니다.
>
> 두번째 차이점은 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있습니다. 하지만 뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.

<br/>

<br/>

<br/>

#### 메모리 관리 기법에 대해 설명해주세요.

> 메모리 할당에는 CMA(Continuous Memory Allocation: 연속 메모리 할당), Paging, Segmentation 있습니다.
>
> >  CMA는 연속된 공간의 메모리를 프로세스에게 할당해주는 방법입니다. 연속적으로 메모리를 할당해주면 프로세스마다 할당된 메모리 공간 사이에 할당되지 않은 빈 공간이 생기게 되는데 이를 Hole이라 합니다. 연속 메모리 공간을 할당해주는 방법에도 3가지 방법이 있습니다.
> >
> > 1) First-Fit : 메모리 요청이 들어왔을 때 요청한 크기를 만족하는 Hole 중 가장 첫 번째 Hole을 할당
> >
> > 2) Best-Fit : 메모리 요청이 들어왔을 때 요청한 크기를 만족하는 Hole 중 가장 작은 크기의 Hole을 할당
> >
> > 3) Worst-Fit : Best-Fit과 반대로 요청한 크기를 만족하는 Hole 중 가장 큰 크기의 Hole을 할당
> >
> > CMA는 외부 단편화 발생과 Compaction 과정으로 인한 오버헤드가 큰 단점이 있습니다.
>
> > Paging은 메인 메모리를 일정한 사이즈의 frame으로 분할하고 프로세스도 그 크기에 맞춰 분할해 할당하는 방법입니다. 분할된 프로세스 조각을 Page라 부릅니다. Page Table에 각 Page가 어느 Frame에 위치하는지 저장됩니다.
>
> > Segmentation은 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할하고, 할당하는 방법입니다. 

<br/>

<br/>

<br/>

# Reference

> - [CPU 스케줄링 - preamtree님](https://preamtree.tistory.com/19)
> - [메모리 관리 기법 - 군옥수수수님](https://baked-corn.tistory.com/16?category=718232)